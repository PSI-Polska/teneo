
Issues integration emf and jpox
===========================================

Handling of bidirectional 1:n relations:
- JPOX can only work with jdo-descriptor files on implementation class level. Only one implementation class per 
interface is supported! 
- enum is handled by storing the string value in a col. in the database. Only issue is that the typewrapper
needs to be registered for each concrete subclass of AbstractEnumerator. This requires package initialisation. 
- (solved, however not for addunique and others) jpox automatically sets the 1-side of the relation when an object is added to a EList. Assume that 
object a is added to the elist of object b, when a is added to the elist of b the following happens:
1) JPOX sets b in the opposite in a, 2) a is added to the elist, 3) the elist sets b in a,
4) emf detects that the opposite was already set and inverseremoves a from b. This results that 
a points to b but that a is not present in the list of b. 
- EList handling does not work correctly for the basicadd calls, if jpox also handles bi-directional relations
then jpox will also for the basic add call set the other side of the relation (without notification chains btw).
So if this is a problem then jpox should not be responsible for handling bi-directional relations.
- The EListWrapper returns EListIterators when the iterator methods are called. In jpox this should maybe be 
scoiterators (which also handle updates). We are not certain about this. 
- A primary key defined in the xsd consisting of multiple fields is not supported. In this case the 
application will automatically use data store identity
- If A refers to B and for this a foreign key field has to be created in table B then it is better (the first time) to do a
makePersistent on A before a B. In this way jpox knows that an extra field should be created in the table B. If the makepersistent
is done the other way around then jpox gets confused.

JPOX evaluation:
- Like: (very very much) its dynamic creation of tables and columns. 
- Like: its distributed definition, package.jdo's may be distributed over different packages and only require 
to describe the contents of that package
- Like: its standards compliance (jdo!)
- Not like: actually only works on concrete class implementation level and not on interface level. This is 
especially difficult for collections of interfaces.
- Not like: less extendable on the area of object creation and collection creation. Missed a bit a 'registrable' factory approach
or an ioc approach (see ojb). There were workable work-arounds for these issues.

OJB evaluation
- Like: its extendability by allowing own factories for object creation and collection creation. Detailed control on how
fields are persisted (PersistentField concept)
- Like: its approach to have multiple layers with different api's (pb, ojb, odmg)
- Like: its very responsive mailing list and developers which were willing to help out when requested
- Like: its support for interfaces when defining or mappings, collection fields and normal object fields (very nice)
- Like: binary class enhancement is not required
- Like: multiple different version of or mappings can be present in one runtime version
- Not like: does not really offer a viable jdo implementation (at least ojb people express that it is not production proof)
- Not like: the creation of tables and columns is not done by ojb but should be done by another tool (commons-sql/ddlutils).
The maturity of these tools is unsure
- Not like: in the standard approach the descriptor files need to be very centralised. This is easily overcome by dynamically
registering new class mappings using direct java calls.
- Not like: does not support lists/collections of simple types

>> TODO
- Support Map
- Automatic Validation at commit or resource save
- Support user-defined types
- More tests, for example testing of jdo queries, testing of different hierarchy mappings
- Extend jpox resource to filter on type
- Now only one type of class hierarchy mapping is supported (default of jpox)

>> Transactions
The following setting should be set to false:
javax.jdo.option.Optimistic = false
JPOX works best with pessimistic transaction, these are actually not so pessimistic because no locking is done. 
The locking of database records is only done when org.jpox.useUpdateLock property is set to true, but we use
false in our test cases here.

>> Fetch Group and resource
>>>>>> DOES NOT WORK COMPLETELY BECAUSE OF CONTAINER REPAIR ACTIONS
The jpox package.jdo generator generates for each class a fetchgroup which only contains the primitive fields and the 
containment references (excluding collections), other reference fields and collections are not read. 
The fetchgroup has the same name as the class.
This fetch group is used when a resource is loaded. Normally jpox loads all primitive fields and single references but
all multi-occurence fields (i.e. collections) are lazely loaded.

If you have very large datasets then it is possible to load a very minimal part of a class (nl. nothing). This is 
accomplished by adding a parameter fetch_minimal=true to the url to retrieve the resource. 

>> EMF Validation
There is a JPOX Life cycle listener which can be attached to a Persistence Manager Factory. This listener will automatically
check if an eobject is valid just before it is stored. See EMFValidationListener.
>>>> DOES NOT WORK because pre-store event is called when an object is only partially constructed.

>> Strange:
org.jpox.delayDatastoreOperationsUntilCommit to true does not work correctly in case of collection or 
two way relations.

>> If a field has a default then a column is added in the field tag.

>> Contained objects should not be added directly to a resource, adding to their container is enough.
If a contained object is added directly to a container then this results in an error (in emf).

>> Lists of user-defined primitive types are not supported, mainly enumerates

>> A contained object can be read directly from the database, if this is done then the 
container value is not set.

>> Two-way relations (1:1) using interfaces
If there are multiple classes implementing an interface used in a two way relation then this does not 
work correctly, when relations are removed by setting fields to null jpox does not correctly nullify the
relevant columns. Note for one way relations this works fine.

Relations and delete and update cascading (A to B)

1:1 one way/two way, Required and Not Required, Contained/Non-Contained
For relations foreign-keys are always set at delete-action="restrict" because the reference has to be
deleted on object level and then the referenced object can be deleted.

For relations null-values are not checked on database level because jpox does not handle this correctly. If 
a reference field is not-nullable then the refering object can not be deleted (because of foreign-key
constraints which are not disabled during a delete of a complete structure).

If contained then dependent="true"

For a two way relation the mapped-by is set on one side of the relation.

If you have 1:1 containment relations then it is important to set the jpox caching property to one of the classes
in org.elver.store.jpox.emf.cache, e.g.:
	properties.setProperty("org.jpox.cache.level1.type", "org.elver.store.jpox.emf.EMFSoftRefCache");
Note that the emf/jpox will automatically use the org.elver.store.jpox.emf.EMFWeakRefCache if you do not set anything.
This class extends the jpox WeakRefCache and has the exact same behavior (in addition to repairing eContainers).
	
and set the following jdo property to false:
	properties.setProperty("javax.jdo.option.IgnoreCache","false");
This is required because the jpox integration uses the addition of an object to the cache as a trigger to set the
eContainer of any of its contained children. Note that for 1:n relations this repair is done differently.

1:n one way, Required
Required means here that A should at least point to one B. This occurence constraint can not be checked/controlled on
sql level (neither can for example a maxOccurs="5" be controlled on sql level). So we should not try to do this! 
The only thing which can be done is set null-value=exception on the field level. 


Note that if the relation is non-contained then always a join table is used because we actually do not know if this is a
1:n or a n:m relation! This is not clear from the xsd.

A-Side
In case of a containment relation the dependent=true should be used and for certainty also the dependent-element=true is
set on the collection.
If not a containment relation then the join table is used, in this case delete-action should maybe not be specified?

We assume here that if B is deleted then jpox will automatically delete the join table record. This assumes that from
the perspective of B the delete-action=null, however because B has no field to set this on we can not specify this!













1:n one way, Not Required
Same case as previous only null-value is not set.

1:n two way, Required by A, Required by B
For two-way relations we can set the delete-action constraints on either side. Note that the delete-action is 
mainly related to the occurence/required constraint on the other side!

A-Side
If B is contained in A then A gets a dependent=true on the field and collection tags.
If B is not contained in A then A gets a delete-action=restricted, because A may not be deleted if a B refers to it.
B-Side

What is specified at the B side, because we do not know the occurence constraints? However 

Similar to previous one for the case of A, however B has a required relation to the A, this means that A can not be
deleted without consequence. However where should the delete-action=restrict be placed?? In the jdo part of A or of B?



1:n two way, Required by A, Not Required by B

1:n two way, Not Required by A, Required by B

1:n two way, Not Required by A, Not Required by B

n:m two way, Requied by A, Required by B

n:m two way, Requied by A, Required by B

n:m two way, Requied by A, Required by B



		JPOXInitializer.INSTANCE.registerPackage(theLibraryPackage);

		// create an initial pmf
		JPOXHelper.INSTANCE.createRegisterPersistenceManagerFactory("library", "com.mysql.jdbc.Driver",
				"jdbc:mysql://127.0.0.1:3306/library", "root", "root", "library");

		Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("library", new JPOXResourceFactory());

