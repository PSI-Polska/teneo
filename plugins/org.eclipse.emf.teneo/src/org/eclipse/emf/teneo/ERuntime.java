/**
 * <copyright>
 *
 * Copyright (c) 2005, 2006 Springsite BV (The Netherlands) and others
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Martin Taal - Initial API and implementation
 *
 * </copyright>
 *
 * $Id: ERuntime.java,v 1.1 2006/07/04 21:04:04 mtaal Exp $
 */

package org.eclipse.emf.teneo;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.impl.EcorePackageImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.xml.type.impl.XMLTypePackageImpl;
import org.eclipse.emf.teneo.util.StoreUtil;

/**
 * The ERuntime contains references to EPackages which are persistable, i.e. are persisted.
 * 
 * It is used to compute information related to concrete class - eclass mapping, interface to concrete class, references for cross
 * reference computation, contained computations.
 * 
 * @author <a href="mailto:mtaal@elver.org">Martin Taal</a>
 * @version $Revision: 1.1 $
 */

public class ERuntime {

	/** The logger */
	private static Log log = LogFactory.getLog(ERuntime.class);

	/** The name of the document root class generated by emf, is ignored in topclasses computation */
	private static final String DOCUMENT_ROOT_NAME = "DocumentRoot";

	/** The singleton instance */
	public static final ERuntime INSTANCE = new ERuntime();

	/** The list of epackages processed here */
	private final ArrayList epackages = new ArrayList();

	/** The mapping from concrete classes to eclass and back */
	private final HashMap concreteToEClass = new HashMap();

	private final HashMap interfaceToEClass = new HashMap();

	private final HashMap eclassToConcrete = new HashMap();

	/** The list of topclasses/interfaces */
	private final ArrayList topClasses = new ArrayList();

	/** The list of contained classes/interfaces */
	private final ArrayList containedClasses = new ArrayList();

	/** Register the epackages */
	public synchronized void register(EPackage[] epacks) {
		for (int i = 0; i < epacks.length; i++) {

			if (!epackages.contains(epacks[i])) {
				epackages.add(epacks[i]);
			}
		}

		computeConcreteInstanceMapping();
		computeContainedClasses();
	}

	/** Resets the maps/lists */
	public void clear() {
		epackages.clear();
		containedClasses.clear();
		concreteToEClass.clear();
		interfaceToEClass.clear();
		eclassToConcrete.clear();
		topClasses.clear();
	}

	/**
	 * Computes which classes are contained and which are non-contained. Method must be called after the computeReferers method!
	 */
	private void computeContainedClasses() {

		topClasses.clear();
		containedClasses.clear();

		for (int i = 0; i < epackages.size(); i++) {
			final EPackage epack = (EPackage) epackages.get(i);
			if (ignorePackage(epack)) {
				continue;
			}

			final Iterator it = epack.getEClassifiers().iterator();
			while (it.hasNext()) {
				final EClassifier eclassifier = (EClassifier) it.next();
				if (!(eclassifier instanceof EClass)) continue;

				final EClass eclass = (EClass) eclassifier;

				// bit ugly compare on name, but document root should be ignored
				// otherwise everything is contained
				if (eclass.getName().compareTo(DOCUMENT_ROOT_NAME) == 0) continue;

				final Iterator erefs = eclass.getEReferences().iterator();
				while (erefs.hasNext()) {
					final EReference eref = (EReference) erefs.next();
					if (!eref.isContainment()) continue;
					final Class toClass = eref.getEType().getInstanceClass();
					if (!containedClasses.contains(toClass)) containedClasses.add(toClass);
				}
			}
		}

		// and then when it is not contained add it to the contained list
		final Iterator it = interfaceToEClass.keySet().iterator();
		while (it.hasNext()) {
			final Class clazz = (Class) it.next();

			if (containedClasses.contains(clazz)) continue; // already determined so continue

			if (isSelfOrSuperContained(clazz, containedClasses)) {
				containedClasses.add(clazz);
			} else {
				topClasses.add(clazz);
			}
		}

		// topclasses are cleaned because they are used to query and otherwise
		// different queries would return overlapping results (because of polymor.)
		cleanList(topClasses);
		cleanList(containedClasses);
	}

	/**
	 * Walks through a interface inheritance structure and determines if a superclass is contained if so then the class is added to the
	 * containedclasses
	 */
	private boolean isSelfOrSuperContained(Class checkClass, ArrayList containedClasses) {
		assert (checkClass.isInterface());
		if (containedClasses.contains(checkClass)) return true;
		final Class[] interfaces = checkClass.getInterfaces();
		for (int i = 0; i < interfaces.length; i++) {
			if (isSelfOrSuperContained(interfaces[i], containedClasses)) return true;
		}
		return false;
	}

	/** Returns the list of topclasses */
	public Class[] getTopClasses() {
		return (Class[]) topClasses.toArray(new Class[topClasses.size()]);
	}

	/** Return the list of interfaces */
	public Set getAllInterfaces() {
		return interfaceToEClass.keySet();
	}

	/** Returns all concrete classes */
	public Set getAllConcreteClasses() {
		return concreteToEClass.keySet();
	}

	/**
	 * Retains only the root parent class in a list, so if an entry in the list as a parent in the same list then the child is deleted
	 * from the list
	 */
	private void cleanList(ArrayList list) {
		final ArrayList toRemove = new ArrayList();
		for (int i = 0; i < list.size(); i++) {
			final Class clazz = (Class) list.get(i);
			if (clazz == null) continue;
			final Class[] supers = clazz.getInterfaces();
			for (int j = 0; j < supers.length; j++) {
				if (list.contains(supers[j])) {
					toRemove.add(clazz);
					break;
				}
			}
		}
		list.removeAll(toRemove);
	}

	/** Determines concrete impl classes for each eclass */
	private void computeConcreteInstanceMapping() {
		concreteToEClass.clear();
		eclassToConcrete.clear();
		interfaceToEClass.clear();

		// walk through all the epackages
		for (int i = 0; i < epackages.size(); i++) {
			final EPackage epack = (EPackage) epackages.get(i);

			if (ignorePackage(epack)) {
				log.debug("Not determining concrete classes for package " + epack.getName());
				continue;
			}

			log.debug("Determining concrete classes for package " + epack.getName());

			final Iterator it = epack.getEClassifiers().iterator();
			while (it.hasNext()) {
				final EClassifier eclassifier = (EClassifier) it.next();

				if (!(eclassifier instanceof EClass)) continue;

				final Object instance = getPersistableInstance(eclassifier);
				if (instance != null) {
					eclassToConcrete.put(eclassifier, instance.getClass());
					concreteToEClass.put(instance.getClass(), eclassifier);
				}
				interfaceToEClass.put(eclassifier.getInstanceClass(), eclassifier);
			}
		}

		// packaged in an extra arraylist to prevent concurrent modification exception.
		final Iterator it = new ArrayList(concreteToEClass.keySet()).iterator();
		while (it.hasNext()) {
			addAbstractSupers((Class) it.next());
		}
	}

	/**
	 * Walks up the class hierarchy and adds the superclasses to the concrete-interface mapping class sets
	 */
	private void addAbstractSupers(Class clazz) {

		// clazz is null or not an eobject
		if (clazz == null || !EObject.class.isAssignableFrom(clazz)) return;

		// if already been here then go on for the superclasses
		if (concreteToEClass.get(clazz) != null) {
			addAbstractSupers(clazz.getSuperclass());
			return;
		}

		// new one, find all its interfaces
		final Class[] interf = clazz.getInterfaces();
		for (int i = 0; i < interf.length; i++) {
			if (EObject.class.isAssignableFrom(interf[i])) {
				final EClass eclass = (EClass) interfaceToEClass.get(interf[i]);
				concreteToEClass.put(clazz, eclass);
				eclassToConcrete.put(eclass, clazz);
			}
		}
	}

	/**
	 * Returns a persistable instance of an eclassifier, if the eclassifier is not persistable/instantiable then null is returned.
	 */
	private Object getPersistableInstance(EClassifier eclassifier) {
		final EClass eclazz = (EClass) eclassifier;

		// abstract instance classes are added later
		if (eclazz.isAbstract() || eclazz.isInterface()) return null;

		// Check if the class is persistable
		try {
			return EcoreUtil.create(eclazz);
		} catch (Exception e) {
			// log but do nothing because this happens when we try to create an object
			// with an invalid classifier, which is a eclass!
			log.debug("The classifier: " + eclassifier.getName() + " is not a valid eclass");

			return null;
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.eclipse.emf.teneo.jpox.emf.IEMFDataStore#getEPackages()
	 */
	public EPackage[] getEPackages() {
		return (EPackage[]) epackages.toArray(new EPackage[epackages.size()]);
	}

	/** Convenience method to easily determine which packages should be ignored */
	private static boolean ignorePackage(EPackage epack) {
		if (epack instanceof XMLTypePackageImpl) return true; // ignore this
		if (epack instanceof EcorePackageImpl) return true; // ignore this
		return false;
	}

	/** Returns the instanceclass for a passed interface */
	public Class getInstanceClass(Class interf) {
		final EClass eclass = (EClass) interfaceToEClass.get(interf);
		if (eclass == null) {
			throw new StoreException("No eclass for interf " + interf.getName());
		}
		final Class result = (Class) eclassToConcrete.get(eclass);
		return result;
	}

	/** Returns the instanceclass for a passed eclass */
	public Class getInstanceClass(EClass eclass) {
		return (Class) eclassToConcrete.get(eclass);
	}

	/** Get the eclass for a certain class */
	public EClass getEClass(Class clazz) {
		if (clazz.isInterface()) {
			return (EClass) interfaceToEClass.get(clazz);
		}
		return (EClass) concreteToEClass.get(clazz);
	}

	/**
	 * Returns the structural feature for a certain field and object comby. Null is returned if nothing is found
	 */
	public EStructuralFeature getStructuralFeature(Class clazz, String FieldName) {
		final EClass eclass = getEClass(clazz);
		if (eclass == null) return null;
		return StoreUtil.getEStructuralFeature(eclass, FieldName);
	}

	/**
	 * Returns the list of EMF interfaces which are contained. Only the topmost interface in a class hierarchy is returned. This can be
	 * used to automatically create the econtainer field mappings.
	 * 
	 * Note that multiple classes in one inheritance structure can be present.
	 */
	public Class[] getContainedInterfaces() {
		return (Class[]) containedClasses.toArray(new Class[containedClasses.size()]);
	}
}